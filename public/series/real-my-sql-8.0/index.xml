&lt;?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0">
    <channel>
        <title>Jay Log</title>
        <link>http://localhost:1313/</link>
        <description></description>
        <language>en-us</language>
        <generator>Hugo -- gohugo.io</generator>
    
        <item>
            <title>ch15. Data type in DB</title>
            <link>http://localhost:1313/posts/database/db_15_2/</link>
            <description>&lt;![CDATA[<h1 id="enum">ENUM</h1>
<ul>
<li>테이블의 구조에 나열된 목록 중 하나의 값을 가질 수 있다.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="w">  </span><span class="k">create</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">tb_enum</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">fd_enum</span><span class="w"> </span><span class="n">enum</span><span class="p">(</span><span class="s1">&#39;PROCESSING&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;FAILURE&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;SUCCESS&#39;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">-- 매핑된 문자열이 아닌 내부적으로 저장된 숫자 값으로 연산이 실행됨
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">select</span><span class="w"> </span><span class="n">fd_enum</span><span class="o">*</span><span class="mi">1</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">fd_enum_real_value</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">tb_enum</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>enum 타입은 쿼리에서 char, varchar 타입과 같은 문자열로 비교하거나 저장할 수 있다.</li>
<li>enum 타입에 사용할 수 있는 최대 아이템 갯수는 65535개
<ul>
<li>아이템 갯수가 255개 미만이면 1바이트를 사용</li>
</ul>
</li>
<li>장점
<ul>
<li>테이블 구조에 정의된 코드 값만 사용할 수 있게 강제한다.</li>
<li>DB 서버의 디스크 저장 공간의 크기를 줄여줌
<ul>
<li>레코드가 많아질수록 효율적</li>
</ul>
</li>
</ul>
</li>
<li>단점
<ul>
<li>
<p>enum 타입에 새로운 값을 추가한다면 테이블의 구조를 변경해야 한다.</p>
<ul>
<li>MySQL 5.6 이전까지는 항상 테이블을 리빌드해야 했음 -&gt; 별로 사용하지 않음</li>
<li>MySQL 5.6 부터는 새로 추가하는 아이템이 enum 타입의 제일 마지막에 추가되는 형태하면 텡블의 구조 변경만으로 즉시 완료된다.</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="w">  </span><span class="k">alter</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">tb_enum</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">modify</span><span class="w"> </span><span class="n">fd_enum</span><span class="w"> </span><span class="n">enum</span><span class="p">(</span><span class="s1">&#39;PROCESSING&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;FAILURE&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;SUCCESS&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;REFUND&#39;</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">algorithm</span><span class="o">=</span><span class="n">instant</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">alter</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">tb_enum</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">modify</span><span class="w"> </span><span class="n">fd_enum</span><span class="w"> </span><span class="n">enum</span><span class="p">(</span><span class="s1">&#39;PROCESSING&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;FAILURE&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;REFUND&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;SUCCESS&#39;</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">algorithm</span><span class="o">=</span><span class="k">copy</span><span class="p">,</span><span class="w"> </span><span class="k">lock</span><span class="o">=</span><span class="n">shared</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>테이블이 매우 크다면 가독성이 조금 떨어지더라도 새로운 아이템을 enum 마지막에 추가하는 것이 MySQL 서버의 가용성을 높이는 방법</li>
</ul>
</li>
</ul>
</li>
<li>enum 타입 값으로 정렬하면 매핑된 코드 값으로 정렬이 수행됨
<ul>
<li>enum은 문자열이 아닌 정수 타입의 컬럼</li>
<li>되도록이면 enum 기준으로 정렬은 안하는게 좋음</li>
</ul>
</li>
</ul>
<h1 id="set">SET</h1>
<ul>
<li>enum과의 차이: set은 하나의 컬럼에 1개 이상의 값을 저장할 수 있다.
<ul>
<li>MySQL 서버는 내부적으로 BIT-OR 연산을 거쳐서 1개 이상의 선택된 값을 저장한다.</li>
<li>여러 개의 값을 저장할 수 있지만 그만큼의 공간을 가지지는 않음</li>
</ul>
</li>
<li>아이템 수가 8개 이하면 1바이트의 저장공간을 가짐</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="w">  </span><span class="k">create</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">tb_set</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">fd_set</span><span class="w"> </span><span class="k">set</span><span class="p">(</span><span class="s1">&#39;TENNIS&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;SOCCER&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;GOLF&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;TABLE-TENNIS&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;BASKETBALL&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;BILLIARD&#39;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">tb_set</span><span class="w"> </span><span class="p">(</span><span class="n">fd_set</span><span class="p">)</span><span class="w"> </span><span class="k">values</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;SOCCER&#39;</span><span class="p">),</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;GOLF,TENNIS&#39;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">tb_set</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">find_in_set</span><span class="p">(</span><span class="s1">&#39;GOLF&#39;</span><span class="p">,</span><span class="w"> </span><span class="n">fd_set</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">tb_set</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">fd_set</span><span class="o">=</span><span class="s1">&#39;GOLF,TENNIS&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>find_in_set 함수나 like로 검색할 수 있음
<ul>
<li>find_in_set 함수는 해당 컬럼에 인덱스가 있어도 효율적으로 인덱스를 이용할 수 없다.</li>
<li>이런 형태의 검색이 빈번히 사용된다면 set 타입의 컬럼을 정규화해서 별도로 인덱스를 가진 자식 테이블을 생성하는 것이 좋다.</li>
</ul>
</li>
<li>equals 비교 시에는 컬럼에 저장된 순서대로 문자열을 나열해야 검색 가능</li>
<li>중간에 아이템이 추가된다면 테이블의 읽기 잠금과 리빌드 작업이 필요
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="w">  </span><span class="k">alter</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">tb_set</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">modify</span><span class="w"> </span><span class="n">fd_set</span><span class="w"> </span><span class="k">set</span><span class="p">(</span><span class="s1">&#39;TENNIS&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;SOCCER&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;GOLF&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;TABLE-TENNIS&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;Football&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;BASKETBALL&#39;</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;BILLIARD&#39;</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">algorithm</span><span class="o">=</span><span class="k">copy</span><span class="p">,</span><span class="w"> </span><span class="k">lock</span><span class="o">=</span><span class="n">shared</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>아이템 갯수가 8 -&gt; 9개로 변경될 때는 set 타입을 저장하기 위한 공간을 2바이트로 변경해야하기 때문에 읽기 잠금과 테이블 리빌드 작업이 필요하다.</li>
</ul>
</li>
</ul>
<h1 id="text와-blob">TEXT와 BLOB</h1>
<table>
<thead>
<tr>
<th>데이터 타입</th>
<th>필요 저장 공간 (L = 저장하고자 하는 데이터의 바이트 수)</th>
<th>저장 가능한 최대 바이트 수</th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYTEXT, TINYBLOB</td>
<td>L + 1바이트</td>
<td>$2^8-1(255)$</td>
</tr>
<tr>
<td>TEXT, BLOB</td>
<td>L + 2바이트</td>
<td>$2^{16} - 1(65535)$</td>
</tr>
<tr>
<td>MEDIUMTEXT, MEDIUMBLOB</td>
<td>L + 3바이트</td>
<td>$2^{24}-1(16777215)$</td>
</tr>
<tr>
<td>LONGTEXT, LONGBLOB</td>
<td>L + 4바이트</td>
<td>$2^{32}-1(4294967295)$</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th></th>
<th>고정길이</th>
<th>가변길이</th>
<th>대용량</th>
</tr>
</thead>
<tbody>
<tr>
<td>문자 데이터</td>
<td>CHAR</td>
<td>VARCHAR</td>
<td>TEXT</td>
</tr>
<tr>
<td>이진 데이터</td>
<td>BINARY</td>
<td>VARBINARY</td>
<td>BLOB</td>
</tr>
</tbody>
</table>
<ul>
<li>TEXT, BLOB 타입 모두 주의하고 남용하면 안됨
<ul>
<li>컬럼 하나에 저장되는 문자열이나 이진 값의 길이가 예측할 수 없이 클 때</li>
<li>일반적으로 하나의 레코드는 전체 크기가 64KB를 넘을 수 없지만 이를 초과할 때</li>
</ul>
</li>
<li>blob/text 컬럼을 조작하는 sql문의 길이가 많이 길어질 수 있음
<ul>
<li>max_allowed_packet 시스템 변수에 설정된 값보다 큰 sql 문장은 MySQL 서버로 전송되지 못하고 오류가 발생할 수 있음</li>
<li>max_allowed_packet 값을 충분히 늘리도록 설정</li>
</ul>
</li>
<li>MySQL 서버에서 text, blob 컬럼의 값이 어떻게 저장되는지는 테이블의 row_format 옵션을 사용한다.
<ul>
<li>별도로 지정되지 않으면 innodb_default_for_format 시스템 변수에 저장된 값으로 적용한다.</li>
<li>MySQL 8.0에서는 사용 가능한 모든 row_format에서는 가능하다면 text/blob 컬럼의 값을 다른 레코드와 같이 저장하려고 하지만 레코드의 최대 길이가 제한적인 문제가 있음
<ul>
<li>레코드의 최대 길이를 초과하면 용량이 큰 컬럼 순서대로 외부 페이지로 옮기면서 레코드의 크기를 맞춘다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="공간-데이터-타입">공간 데이터 타입</h1>
<ul>
<li>MySQL 서버는 OpenGIS에서 제시하는 표준을 준수함
<ul>
<li>WKT (Well Known Text) or WKB (Well Known Binary)를 이용해서 공간 데이터를 관리할 수 있게 지원</li>
<li>MySQL에서 제공하는 공간 정보 저장용 데이터 타입: POINT, LINESTRING, POLYGON, GEOMETRY, GEOMETRYCOLLECTION 등</li>
</ul>
</li>
<li>geometry로 하나의 점/선/다각형을 저장하거나 geometrycollection으로 여러개의 데이터를 저장할 수 있음</li>
</ul>
<h2 id="공간-데이터-생성">공간 데이터 생성</h2>
<ul>
<li>MySQL 서버에서 공간 데이터를 생성할 때는 WKT 포맷을 이진 데이터 포맷의 데이터로 변환할 수 있음
<ul>
<li>WKT 포맷: POINT(x y)</li>
<li>객체 생성: ST_PointFromText(&lsquo;POINT(x y)&rsquo;)
<ul>
<li>FromText 대신 FromWKB를 사용하면 WKB를 이용한 공간 데이터 객체를 생성한다.</li>
</ul>
</li>
</ul>
</li>
<li>두번째 파라미터로 SRID를 설정 가능
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="w">  </span><span class="n">ST_PointFromText</span><span class="p">(</span><span class="s1">&#39;POINT(10,20)&#39;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">ST_PointFromText</span><span class="p">(</span><span class="s1">&#39;POINT(37.123123, 127.233243)&#39;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">ST_PointFromText</span><span class="p">(</span><span class="s1">&#39;POINT(10,20)&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">ST_PointFromText</span><span class="p">(</span><span class="s1">&#39;POINT(37.123123, 127.233243)&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">4326</span><span class="p">)</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>SRID를 명시하지 않으면 <code>SRID=0</code>인 객체를 생성한다.</li>
</ul>
</li>
</ul>
<h2 id="공간-데이터-조회">공간 데이터 조회</h2>
<ul>
<li>MySQL 서버가 관리하는 공간 데이터를 조회하는 방법
<ul>
<li>이진 데이털 조회 (WKB 포맷 or MySQL 이진 포맷)</li>
<li>텍스트 데이터 조회 (WKT 포맷)</li>
<li>공간 데이터의 속성 함수를 이용한 조회</li>
<li>1, 2번째는 공간 데이터 타입과 관계없이 ST_AsText() / ST_AsWKT() or ST_AsBinary() / ST_AsWKB() 함수로 조회 가능</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="w">  </span><span class="k">set</span><span class="w"> </span><span class="o">@</span><span class="n">poi</span><span class="p">:</span><span class="o">=</span><span class="n">ST_PointFromText</span><span class="p">(</span><span class="s1">&#39;POINT(37.123123 127.123123)&#39;</span><span class="p">,</span><span class="w"> </span><span class="mi">4326</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">select</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">ST_SRID</span><span class="p">(</span><span class="o">@</span><span class="n">poi</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">srid</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">ST_X</span><span class="p">(</span><span class="o">@</span><span class="n">poi</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">coord_x</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">ST_Y</span><span class="p">(</span><span class="o">@</span><span class="n">poi</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">coord_y</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">ST_Latitude</span><span class="p">(</span><span class="o">@</span><span class="n">poi</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">coord_latitude</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">ST_Longitude</span><span class="p">(</span><span class="o">@</span><span class="n">poi</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">coord_longitude</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">-- ST_Latitude ST_Longitude는 위도/경도를 사용하는 좌표시스템의 공간 데이터에서만 사용 가능
</span></span></span></code></pre></td></tr></table>
</div>
</div><h1 id="json-타입">JSON 타입</h1>
<ul>
<li>MySQL 5.7 부터 JSON 데이터를 저장할 수 있는 JSON 타입이 지원되기 시작</li>
<li>MySQL 8.0 부터 많은 기능과 성능이 개선됨</li>
<li>MySQL 서버에서 TEXT, BLOB 컬럼에 JSON 데이터를 저장할 수는 있음</li>
<li>MySQL 5.7부터 지원되는 JSON 데이터 컬럼은 문자열 저장이 아닌 MongoDB와 같이 바이너리 포맷의 BSON(Binary JSON)으로 변환해서 저장한다.</li>
</ul>
<h2 id="저장-방식">저장 방식</h2>
<ul>
<li>BSON 타입으로 변환해서 저장하기 때문에 TEXT/BLOB보다 공간 효율이 높은 편</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="w">  </span><span class="k">create</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">tb_json</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="w"> </span><span class="nb">int</span><span class="p">,</span><span class="w"> </span><span class="n">fd</span><span class="w"> </span><span class="n">json</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">tb_json</span><span class="w"> </span><span class="k">values</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;{&#34;user_id&#34;: 123}&#39;</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;{&#34;user_id&#34;: &#34;123&#34;}&#39;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">select</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">json_type</span><span class="p">(</span><span class="n">fd</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="s2">&#34;$.user_id&#34;</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">field_type</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">json_storage_size</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="n">byte_size</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="n">tb_json</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>json document가 MySQL 서버의 JSON 컬럼에 저장되면 이진 데이터로 변환하여 저장한다.</li>
<li>용량이 매우 큰 document가 저장되면 MySQL 서버는 16KB 단위로 여러 개의 데이터 페이지로 나뉘어 저장한더.
<ul>
<li>MySQL 5.7 까지는 BLOB 페이지들이 단순 연결 리스트처럼 관리되었음</li>
<li>MySQL 8.0 부터는 BLOB 페이지들의 인덱스를 관리하고, 각 인덱스는 실제 BLOB 데이터를 가진 페이지들의 링크를 갖도록 개선함</li>
</ul>
</li>
</ul>
<h2 id="부분-업데이트-성능">부분 업데이트 성능</h2>
<ul>
<li>MySQL 8.0 부터 JSON 타입에 대해 부분 업데이트 기능 제공</li>
<li>JSON_SET() JSON_REPLACE() JSON_REMOVE() 함수를 이용해서 JSON document의 특정 필드 값을 변경하거나 삭제하는 경우에만 작동</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="w">  </span><span class="k">update</span><span class="w"> </span><span class="n">tb_json</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">set</span><span class="w"> </span><span class="n">fd</span><span class="o">=</span><span class="n">json_set</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;$.user_id&#39;</span><span class="p">,</span><span class="w"> </span><span class="s2">&#34;12345&#34;</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">where</span><span class="w"> </span><span class="n">id</span><span class="o">=</span><span class="mi">2</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">select</span><span class="w"> </span><span class="n">id</span><span class="p">,</span><span class="w"> </span><span class="n">fd</span><span class="p">,</span><span class="w"> </span><span class="n">json_storage_size</span><span class="p">(</span><span class="n">fd</span><span class="p">),</span><span class="w"> </span><span class="n">json_storage_free</span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">from</span><span class="w"> </span><span class="n">tb_json</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><table>
<thead>
<tr>
<th>id</th>
<th>fd</th>
<th>json_storage_size(fd)</th>
<th>json_storage_free(fd)</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>{&ldquo;user_id&rdquo;, 1234567890}</td>
<td>23</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>{&ldquo;user_id&rdquo;, &ldquo;12345&rdquo;}</td>
<td>30</td>
<td>5</td>
</tr>
</tbody>
</table>
<ul>
<li>위 변경 작업이 <code>부분 업데이트</code>로 처리되었는지는 확인할 수 없음
<ul>
<li><code>json_storage_size</code>, <code>json_storage_free</code> 함수로 대략 예측</li>
<li>두번째 레코드는 json_storage_free가 5로 표시됨
<ul>
<li>&ldquo;12345&quot;로 변경되면서 앞 부분의 5바이트 사용, 5바이트는 비움</li>
</ul>
</li>
<li>해당 필드의 값을 10바이트보다 큰 값으로 저장할 경우
<ul>
<li>json_set() 함수를 사용해도 부분 업데이트 진행 x</li>
<li>최초 할당된 공간이 부족해서 MySQL 서버가 JSON 컬럼 or 두번째 레코드를 다른 위치로 복사해서 저장</li>
</ul>
</li>
</ul>
</li>
<li>MySQL 내부적으로 json 컬럼의 값은 BLOB 타입으로 저장되는데 실제 json 컬럼의 값은 4GB까지 값을 가질 수 있음
<ul>
<li>1MB json 데이터를 저장해도 MySQL 서버는 16KB * 64개 페이지를 사용함
<ul>
<li>부분 업데이트를 한다면 1개의 페이지만 변경하면 되고, 안되면 모든 페이지를 다시 디스크로 기록해야함</li>
</ul>
</li>
</ul>
</li>
<li>단순 정수필드의 값을 변경하는 작업은 항상 부분 업데이트 기능이 적용</li>
<li>문자열 타입의 필드라면 문자열의 길이에 따라 부분 업데이트가 되지 않을수도 있음
<ul>
<li>자주 길이가 변한다면 해당 필드가 가질 수 있는 최대 길이로 초기화하거나 애플리케이션에서 추가로 패딩해서 고정 길이의 문자열로 만들어서 저장하는 방법이 있음</li>
</ul>
</li>
</ul>
<h2 id="json-타입-콜레이션과-비교">JSON 타입 콜레이션과 비교</h2>
<ul>
<li>json 컬럼에 저장되는 데이터와 이를 가공해서 나온 결과는 모두 utf8mb4 문자 집합과 utf8mb4_bin 콜레이션을 가진다.
<ul>
<li>utf8mb4_bin 콜레이션은 바이너리 콜레이션이므로 json을 가공해서 나온 문자열은 대소문자나 액센트 문자도 구분해서 비교한다.</li>
</ul>
</li>
</ul>
<h2 id="json-컬럼-선택">JSON 컬럼 선택</h2>
<ul>
<li>TEXT/BLOB vs JSON
<ul>
<li>TEXT/BLOB에 json 문자열을 저장하는 경우 아무런 변환과정을 거치지 않고 값을 디스크에 저장한다.</li>
<li>JSON 타입은 json 데이터를 이진 포맷으로 컴팩션해서 저장하고, 필요한경우 부분 업데이트를 통한 빠른 변경 기능을 제공한다.</li>
<li>A무조건 json 타입 사용이 좋음</li>
</ul>
</li>
<li>정규화한 컬럼 vs json 컬럼
<ul>
<li>json 컬럼만 유지하는 경우에도 필요한 인덱스를 모두 생성할 수 있음</li>
<li>MySQL 8.0부터 멀티 밸류 인덱스 기능이 지원되기 때문에 json document에서 array 타입의 필드에도 인덱스를 생성할 수 있게됨</li>
<li>성능을 중심으로 판단한다면 정규화된 컬럼을 추천</li>
<li>테이블을 너무 정규화했을때 테이블 갯수가 많아지더간 응용 프로그램의 코드도 길어질 수 있음
<ul>
<li>중요도가 낮다면 json 컬럼 사용도 가능</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="가상-컬럼-파생-컬럼">가상 컬럼 (파생 컬럼)</h1>
<ul>
<li>MySQL 서버의 가상 컬럼은 <code>가상 컬럼</code>/<code>스토어드 컬럼</code>으로 구분</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="w">  </span><span class="c1">-- 가상 컬럼
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">create</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">tb_virual_column</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">null</span><span class="w"> </span><span class="n">auto_increment</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">price</span><span class="w"> </span><span class="nb">decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">null</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="s1">&#39;0.00&#39;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">quantity</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">null</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">total_price</span><span class="w"> </span><span class="nb">decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="p">(</span><span class="n">quantity</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">price</span><span class="p">)</span><span class="w"> </span><span class="n">virtual</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">primary</span><span class="w"> </span><span class="k">key</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">-- 스토어드 컬럼
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">create</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">tb_stored_column</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">null</span><span class="w"> </span><span class="n">auto_increment</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">price</span><span class="w"> </span><span class="nb">decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">null</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="s1">&#39;0.00&#39;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">quantity</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">null</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="mi">1</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">total_price</span><span class="w"> </span><span class="nb">decimal</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="p">(</span><span class="n">quantity</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">price</span><span class="p">)</span><span class="w"> </span><span class="n">stored</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">primary</span><span class="w"> </span><span class="k">key</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>컬럼의 정의 뒤에 as절로 계산식을 정의한다.
<ul>
<li>마지막에 <code>stored</code> 키워드가 사용되면 스토어드 컬럼으로 생성되며, 그 외에는 가상 컬럼으로 생성된다. (default는 virtual)</li>
</ul>
</li>
<li>가상 컬럼의 표현식은 입력이 동일하면 시점과 관계없이 결과가 항상 동일한 표현식만 사용할 수 있음
<ul>
<li>사용자 변수나 not-deterministic 옵션의 함수나 표현식 사용할 수 없음</li>
<li>MySQL 8.0 까지는 가상 컬럼의 표현식에 서브쿼리나 스토어드 프로그램을 사용할 수 없음</li>
</ul>
</li>
<li>가상/스토어드 컬럼 모두 다른 컬럼의 값을 참조해서 새로운 값을 만들어 관리한다는 공통점이 있음
<ul>
<li>단점
<ul>
<li>가상 컬럼
<ul>
<li>컬럼의 값이 디스크에 저장되지 않음</li>
<li>컬럼의 구조 변경은 테이블 리빌드를 필요로 하지 않음</li>
<li>컬럼의 값은 레코드가 읽히기 전 또는 before 트리거 실행 직후에 계산되어 만들어짐</li>
</ul>
</li>
<li>스토어드 컬럼
<ul>
<li>컬럼의 값이 물리적으로 디스크에 저장됨</li>
<li>컬럼의 구조 변경은 다른 일반 테이블과 같이 필요 시 테이블 리빌드 방식으로 처리됨</li>
<li>insert, update 시점에만 컬럼의 값이 계산됨</li>
</ul>
</li>
</ul>
</li>
<li>차이
<ul>
<li>계산된 컬럼의 값이 디스크에 실제 저장되는지 여부
<ul>
<li>가상 컬럼은 디스크에 저장되지 않지만 항상 그런건 아님</li>
</ul>
</li>
</ul>
</li>
<li>가상 컬럼은 데이터를 조회하는 시점에 매번 계산되기 때문에 가상 컬럼의 값을 계산하는 과정이 복잡하고 시간이 오래걸린다면 스토어드 컬럼으로 변경하는 것이 성능 향상에 좋음</li>
</ul>
</li>
</ul>
]]></description>
            <pubDate>Fri, 29 Mar 2024 14:00:00 &#43;0000</pubDate>
            <guid isPermaLink="true">http://localhost:1313/posts/database/db_15_2/</guid>
        </item>
    
        <item>
            <title>ch15. Data type in DB</title>
            <link>http://localhost:1313/posts/database/db_15_1/</link>
            <description>&lt;![CDATA[<h1 id="저장-공간">저장 공간</h1>
<ul>
<li>
<p>char vs varchar: 둘다 문자열을 저장할 수 있는 데이터 타입, 차이는 고정/가변 길이</p>
<ul>
<li>두 타입 모두 한 글자를 저장하기 위해 사용하는 문자 집합에 따라 1 ~ 4바이트를 사용한다.</li>
<li>char에 저장될 때는 추가 공간이 필요없지만 varchar에 저장할 때는 문자열의 길이를 관리하기 위한 1 ~ 2바이트의 추가 공간이 필요함</li>
<li>varchar 타입의 길이가 255바이트 이하면 1바이트만 사용, 256바이트 이상이면 2바이트를 사용한다.
<ul>
<li>varchar 타입의 최대 길이는 65536 바이트 <code>256 * 256</code></li>
</ul>
</li>
</ul>
</li>
<li>
<p>char, varchar를 결정하는 기준</p>
<ul>
<li>저장되는 문자열의 길이가 비슷한지</li>
<li>컬럼의 값이 자주 변경되는지</li>
</ul>
<p><img src="/images/15_1.jpg" alt="photo"></p>
<p><img src="/images/15_2.jpg" alt="photo"></p>
<ul>
<li>char 타입은 이미 준비된 공간에 값을 업데이트하면 된다.</li>
<li>varchar 타입에서 길이가 더 큰 값으로 변경되면 레코드 자체를 다른 공간으로 옮겨서 저장해야 한다.
<ul>
<li>레코드의 이동이나 분리는 char보다 더 큰 공간이나 자원을 낭비함</li>
</ul>
</li>
</ul>
</li>
<li>
<p>char, varchar 키워드 뒤에 인자값 n</p>
<ul>
<li>바이트 크기가 아닌 글자 크기를 명시</li>
<li>일반적으로 영어를 포함한 서구권 언어는 각 문자가 1바이트를 사용하므로 10바이트를 사용</li>
<li>한국어/일본어 같은 아시아권 언어는 각 문자가 최대 2바이트를 사용하므로 20바이트를 사용</li>
<li>UTF-8과 같은 유니코드는 최대 4바이트까지 사용하므로 40바이트를 사용</li>
</ul>
</li>
</ul>
<h2 id="저장-공간과-스키마-변경-online-ddl">저장 공간과 스키마 변경 (Online DDL)</h2>
<ul>
<li>MySQL 서버는 데이터가 변경되는 도중에도 스키마를 변경할 수 있도록 Online DDL을 제공
<ul>
<li>모든 스키마 변경이 온라인으로 가능한건 아님</li>
<li>변경 작업의 특성에 따라 select는 가능, 데이터 변경은 불가능할 수 있음</li>
<li>varchar 컬럼의 길이를 늘리는 작업은 작업의 길이에 따라 빠르게 처리될 수 있지만 읽기 잠금을 걸고 레코드를 복사하는 작업이 필요할 수 있음</li>
</ul>
</li>
</ul>
<p><img src="/images/online_ddl.jpg" alt="photo"></p>
<ul>
<li>컬럼의 타입을 varchar(63)으로 늘리는 경우 잠금 없이 빠르게 변경될 수 있음</li>
<li>varchar(64)으로 늘리는 경우 inplace 알고리즘으로 스키마 변경이 허용되지 않음
<ul>
<li>copy 알고리즘으로 변경 -&gt; 읽기잠금 필요, 시간도 오래걸림</li>
</ul>
</li>
<li>utf8mb4 문자 집합을 사용하는 varchar(60)은 최대 길이가 240바이트라서 1바이트면 된다.</li>
<li>varchar(64)은 문자열의 최대인 256바이트보다 크기 때문에 2바이트로 변경되어야 한다.
<ul>
<li>MySQL 서버는 읽기 잠금을 걸어서 데이터 변경을 막고 테이블의 레코드를 복사하는 방식으로 처리함</li>
<li>varchar 타입의 길이가 크게 변경될 것으로 예상된다면 길이 저장 공간의 크기가 바뀌지 않도록 미리 조금 크게 설계하는 것이 좋음</li>
</ul>
</li>
</ul>
<h2 id="문자-집합-캐릭터-셋">문자 집합 (캐릭터 셋)</h2>
<ul>
<li>
<p>문자 집합은 문자열을 사용하는 char, varchar, text 타입의 컬럼에만 설정할 수 있음</p>
</li>
<li>
<p>MySQL에서는 MySQL 서버와 DB, 테이블 단위로 기본 문자 집합을 설정할 수 있음</p>
<ul>
<li>테이블의 문자 집합을 UTF-8로 설정하면 컬럼의 문자 집합을 별도로 지정하지 않아도 UTF-8을 사용</li>
</ul>
</li>
<li>
<p>최근에는 여러 나라의 언어를 동시에 지원하기 위해 utf8mb4을 사용하는 추세</p>
</li>
<li>
<p>MySQL 서버에서 사용 가능한 문자 집합은 <code>SHOW CHARACTER SET</code> 명령으로 확인한다.<br>
<img src="/images/show_character_set.jpg" alt="photo"></p>
<ul>
<li><code>default collation</code> 컬럼에는 해당 문자 집합의 기본 콜레이션을 표시</li>
</ul>
</li>
<li>
<p>MySQL에는 문자 집합을 설정하는 시스템 변수가 여러가지 있음</p>
<p><img src="/images/15_3.jpg" alt="photo"></p>
</li>
</ul>
<h2 id="클라이언트로부터-쿼리를-요청했을-때의-문자-집합-변환">클라이언트로부터 쿼리를 요청했을 때의 문자 집합 변환</h2>
<ul>
<li>MySQL 서버는 클라이언트로부터 받은 메시지가 character_set_client에 지정된 문자 집합으로 인코딩되어 있다고 판단하고, 받은 문자열 데이터를 character_set_connection에 정의된 문자 집합으로 변환한다.
<ul>
<li>SQL 문장에 별도의 문자 집합이 지정된 문자열은 변환 대상이 아님
<ul>
<li>SQL 문장에서 별도로 문자 집합을 설정하는 지정자를 <code>인트로듀서</code>라고 함
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="w">  </span><span class="k">select</span><span class="w"> </span><span class="n">emp_no</span><span class="p">,</span><span class="w"> </span><span class="n">first_name</span><span class="p">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">employees</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">first_name</span><span class="o">=</span><span class="s1">&#39;Matt&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">select</span><span class="w"> </span><span class="n">emp_no</span><span class="p">,</span><span class="w"> </span><span class="n">first_name</span><span class="p">,</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">employees</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">first_name</span><span class="o">=</span><span class="n">_latin1</span><span class="s1">&#39;Matt&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>1번 쿼리의 &lsquo;Matt&rsquo;은 character_set_connection으로 문자 집합이 변환된 이후 처리</li>
<li>2번 쿼리는 인트로듀서가 사용되어 문자 집합의 변환되지 않음</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="처리-결과를-클라이언트로-전송할-때의-문자-집합-변환">처리 결과를 클라이언트로 전송할 때의 문자 집합 변환</h2>
<ul>
<li>character_set_connection에 정의된 문자 집합으로 변환해 SQL을 실행한 다음 MySQL 서버는 쿼리의 결과를 character_set_results 변수에 설정된 문자 집합으로 변환해서 클라이언트로 전송한다.
<ul>
<li>결과 셋에 포함된 컬럼의 값이나 컬럼명과 같은 메타데이터는 모두 character_set_results로 인코딩되어 클라이언트로 전송된다.</li>
</ul>
</li>
<li>변환 전/후의 문자 집합이 똑같다면 별도의 문자 집합 변환 작업은 모두 생략한다.</li>
</ul>
<h2 id="콜레이션-collation">콜레이션 (Collation)</h2>
<ul>
<li>문자열 컬럼의 값에 대한 비교나 정렬 순서를 위한 규칙</li>
</ul>
<h3 id="콜레이션-이해">콜레이션 이해</h3>
<ul>
<li>하나의 문자 집합에 속한 콜레이션은 다른 문자 집합과 공유해서 사용할 수 없음</li>
<li>콜레이션을 지정하지 않으면 디폴트 값으로 지정</li>
<li>MySQL 서버에서 사용 가능한 콜레이션은 <code>show collation</code> 명령으로 확인
<ul>
<li>일반적으로 콜레이션의 이름은 2 or 3개의 파트로 구분되어 있음
<ul>
<li>3개의 파트로 구성된 콜레이션
<ul>
<li>첫번째 파트는 문자 집합의 이름</li>
<li>두번째 파트는 해당 문자 집합의 하위 분류</li>
<li>세번째 파트는 대/소문자 구분 여부
<ul>
<li><code>ci</code>이면 대소문자 구분x, <code>cs</code>면 대소문자 구분o</li>
</ul>
</li>
</ul>
</li>
<li>2개의 파트로 구성된 콜레이션
<ul>
<li>첫번째 파트는 문자 집합의 이름</li>
<li>두번째 파트는 <code>bin</code>
<ul>
<li>이진 데이터를 의미, 별도의 콜레이션을 가지지 않음</li>
<li>비교 및 정렬은 실제 문자 데이터의 바이트 값 기준으로 수행</li>
</ul>
</li>
</ul>
</li>
<li><code>utf8mb4</code>
<ul>
<li>액센트 문자의 구분 여부 추가 (ai, as)</li>
<li><code>utf8mb4_0900_ai_ci</code>: 액센트를 가지지 않은 문자</li>
<li><code>utf8mb4_0900_as_ci</code>: 액센트를 가진 문자</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="w">  </span><span class="k">create</span><span class="w"> </span><span class="k">database</span><span class="w"> </span><span class="n">db_test</span><span class="w"> </span><span class="nb">character</span><span class="w"> </span><span class="k">set</span><span class="o">=</span><span class="n">utf8mb4</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">create</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">tb_member</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">member_id</span><span class="w"> </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">null</span><span class="w"> </span><span class="k">collate</span><span class="w"> </span><span class="n">latin1_general_cs</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">member_name</span><span class="w"> </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">null</span><span class="w"> </span><span class="k">collate</span><span class="w"> </span><span class="n">utf8_bin</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">member_email</span><span class="w"> </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">null</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="p">...</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>create database 명령으로 기본 문자 집합이 utf8mb4인 db를 생성</li>
<li>create table 명령에서 각 컬럼이 서로 다른 문자 집합이나 콜레이션을 사용하도록 정의</li>
</ul>
<h3 id="utf8mb4-문자-집합의-콜레이션">utf8mb4 문자 집합의 콜레이션</h3>
<table>
<thead>
<tr>
<th>콜레이션</th>
<th>UCA 버전</th>
</tr>
</thead>
<tbody>
<tr>
<td>uf8_unicode_ci</td>
<td>4.0.0</td>
</tr>
<tr>
<td>utf8_unicode_520_ci</td>
<td>5.2.0</td>
</tr>
<tr>
<td>utf8mb4_unicode_520_ci</td>
<td>5.2.0</td>
</tr>
<tr>
<td>utf8mb4_0900_ai_ci</td>
<td>9.0.0</td>
</tr>
</tbody>
</table>
<ul>
<li>숫자 값이 포함되지 않은 콜레이션은 4.0.0버전</li>
<li>콜레이션 이름에 Locale이 포함되어 있는지 여부로 언어에 종속적인 콜레이션과 비종속적인 콜레이션으로 구분할 수 있음</li>
<li>UCA 9.0.0 버전은 이전의 버전보다 빠르다고 MySQL 매뉴얼에서 소개함
<ul>
<li>실제로는 크게 성능 영향은 없음</li>
</ul>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="w">  </span><span class="c1">-- 0.58 sec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">set</span><span class="w"> </span><span class="k">names</span><span class="w"> </span><span class="n">utf8mb4</span><span class="w"> </span><span class="k">collate</span><span class="w"> </span><span class="n">utf8mb4_general_ci</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">select</span><span class="w"> </span><span class="n">benchmark</span><span class="p">(</span><span class="mi">10000000</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;한글입니까&#39;</span><span class="o">=</span><span class="s1">&#39;한글입니다&#39;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">-- 1.71 sec
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">set</span><span class="w"> </span><span class="k">names</span><span class="w"> </span><span class="n">utf8mb4</span><span class="w"> </span><span class="k">collate</span><span class="w"> </span><span class="n">utf8mb4_0900_ai_ci</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">select</span><span class="w"> </span><span class="n">benchmark</span><span class="p">(</span><span class="mi">10000000</span><span class="p">,</span><span class="w"> </span><span class="s1">&#39;한글입니까&#39;</span><span class="o">=</span><span class="s1">&#39;한글입니다&#39;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>속도 차이가 크지 않기 때문에 콜레이션 결정 기준을 성능을 기준으로 하기보단 필요에 따라 결정하는 것을 권장</li>
</ul>
<h2 id="비교-방식">비교 방식</h2>
<ul>
<li>char, varchar의 비교 방식은 거의 같음</li>
<li>MySQL 서버에서 지원하는 대부분의 문자 집합과 콜레이션에서 char, varchar 타입을 비교할 때 공백문자를 뒤에 붙여서 문자열의 길이를 동일하게 만든 후 비교</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="w">  </span><span class="c1">-- true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">select</span><span class="w"> </span><span class="s1">&#39;ABC&#39;</span><span class="o">=</span><span class="s1">&#39;ABC   &#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">-- false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">select</span><span class="w"> </span><span class="s1">&#39;ABC&#39;</span><span class="o">=</span><span class="s1">&#39;   ABC&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>utf8mb4 문자집합이 UCA버전 9.0.0을 지원하면서 문자열 뒤 공백에 대한 비교 방식이 달라짐</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="w">  </span><span class="c1">-- true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">set</span><span class="w"> </span><span class="k">names</span><span class="w"> </span><span class="n">utf8mb4</span><span class="w"> </span><span class="k">collate</span><span class="w"> </span><span class="n">utf8mb4_bin</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">select</span><span class="w"> </span><span class="s1">&#39;a &#39;</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">-- false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">set</span><span class="w"> </span><span class="k">names</span><span class="w"> </span><span class="n">utf8mb4</span><span class="w"> </span><span class="k">collate</span><span class="w"> </span><span class="n">utf8mb4_0900_bin</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">select</span><span class="w"> </span><span class="s1">&#39;a &#39;</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="w">  </span><span class="k">select</span><span class="w"> </span><span class="k">collation_name</span><span class="p">,</span><span class="w"> </span><span class="n">pad_attribute</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">from</span><span class="w"> </span><span class="n">information_schema</span><span class="p">.</span><span class="n">collations</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="k">where</span><span class="w"> </span><span class="k">collation_name</span><span class="w"> </span><span class="k">like</span><span class="w"> </span><span class="s1">&#39;utf8mb4%&#39;</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>문자 집합이 문자열 뒤의 공백이 비교 결과에 영향이 있는지는 information_schema db의 collations 뷰에서 pad_attribute 컬럼의 값으로 판단
<ul>
<li><code>pad space</code>로 표시된 콜레이션은 비교 대상 문자열의 길이가 같아지도록 공백을 채움</li>
<li><code>no pad</code>로 표시된 콜레이션은 문자열에 공백을 채우지 않고 그대로 비교
<ul>
<li>비교 대상 문자열의 길이가 많이 차이나는 경우 더 빠른 성능</li>
</ul>
</li>
</ul>
</li>
<li><code>like</code>를 사용한 문자열 패턴 비교는 공백 문자가 유효 문자로 취급됨
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="w">  </span><span class="c1">-- false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">select</span><span class="w"> </span><span class="s1">&#39;ABC   &#39;</span><span class="w"> </span><span class="k">like</span><span class="w"> </span><span class="o">`</span><span class="n">ABC</span><span class="o">`</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">-- false
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">select</span><span class="w"> </span><span class="s1">&#39;   ABC&#39;</span><span class="w"> </span><span class="k">like</span><span class="w"> </span><span class="o">`</span><span class="n">ABC</span><span class="o">`</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">-- true
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">select</span><span class="w"> </span><span class="s1">&#39;ABC   &#39;</span><span class="w"> </span><span class="k">like</span><span class="w"> </span><span class="o">`</span><span class="n">ABC</span><span class="o">%`</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<h2 id="문자열-이스케이프-처리">문자열 이스케이프 처리</h2>
<table>
<thead>
<tr>
<th>이스케이프 표기</th>
<th>의미</th>
</tr>
</thead>
<tbody>
<tr>
<td>\0</td>
<td>ascii null문자 (0x00)</td>
</tr>
<tr>
<td>\&rsquo;</td>
<td>홑따옴표(')</td>
</tr>
<tr>
<td>\&quot;</td>
<td>쌍따옴표(&quot;)</td>
</tr>
<tr>
<td>\b</td>
<td>백스페이스 문자</td>
</tr>
<tr>
<td>\n</td>
<td>개행문자</td>
</tr>
<tr>
<td>\r</td>
<td>캐리지 리턴 문자 (window에서는 \r\n 조합으로 개행문자 사용)</td>
</tr>
<tr>
<td>\t</td>
<td>탭 문자</td>
</tr>
<tr>
<td>\\</td>
<td>백 슬래시 문자(\)</td>
</tr>
<tr>
<td>\%</td>
<td>퍼센트 문자</td>
</tr>
<tr>
<td>\_</td>
<td>언더 스코어 문자</td>
</tr>
</tbody>
</table>
<ul>
<li>%, _ 문자는 like를 사용하는 패턴 검색에서만 사용 가능</li>
<li><code>'</code> <code>&quot;</code>를 두번 연속으로 표기해서 이스케이프 처리할 수 있음</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="w">  </span><span class="k">create</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">tb_char_escape</span><span class="w"> </span><span class="p">(</span><span class="n">fd1</span><span class="w"> </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">100</span><span class="p">));</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">-- ab&#39;ba
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">tb_char_escape</span><span class="w"> </span><span class="k">values</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;ab&#39;&#39;ba&#39;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">-- ab&#34;ba
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">tb_char_escape</span><span class="w"> </span><span class="k">values</span><span class="w"> </span><span class="p">(</span><span class="s2">&#34;ab&#34;&#34;ba&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">-- ab&#39;ba
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">tb_char_escape</span><span class="w"> </span><span class="k">values</span><span class="w"> </span><span class="p">(</span><span class="s2">&#34;ab\&#39;ba&#34;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">-- ab&#34;ba
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">tb_char_escape</span><span class="w"> </span><span class="k">values</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;ab\&#34;ba&#39;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">-- ab&#34;&#34;ba
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">tb_char_escape</span><span class="w"> </span><span class="k">values</span><span class="w"> </span><span class="p">(</span><span class="s1">&#39;ab&#34;&#34;ba&#39;</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">-- ab&#39;&#39;ba
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">tb_char_escape</span><span class="w"> </span><span class="k">values</span><span class="w"> </span><span class="p">(</span><span class="s2">&#34;ab&#39;&#39;ba&#34;</span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>홑/쌍따옴표를 쌍/홑따옴표로 감싸면 이스케이프 처리가 되지 않음</li>
</ul>
<h2 id="정수">정수</h2>
<table>
<thead>
<tr>
<th>데이터 타입</th>
<th>저장 공간 (Bytes)</th>
<th>최솟값(signed)</th>
<th>최솟값(unsigned)</th>
<th>최댓값(signed)</th>
<th>최댓값(unsigned)</th>
</tr>
</thead>
<tbody>
<tr>
<td>TINYINT</td>
<td>1</td>
<td>-128</td>
<td>0</td>
<td>127</td>
<td>255</td>
</tr>
<tr>
<td>SMALLINT</td>
<td>2</td>
<td>-32768</td>
<td>0</td>
<td>32767</td>
<td>65535</td>
</tr>
<tr>
<td>MEDIUMINT</td>
<td>3</td>
<td>-8388608</td>
<td>0</td>
<td>8388607</td>
<td>16777215</td>
</tr>
<tr>
<td>INT</td>
<td>4</td>
<td>-2147483648</td>
<td>0</td>
<td>2147483647</td>
<td>4294967295</td>
</tr>
<tr>
<td>BIGINT</td>
<td>8</td>
<td>-263</td>
<td>0</td>
<td>263-1</td>
<td>264-1</td>
</tr>
</tbody>
</table>
<ul>
<li>정수 타입은 unsigned 옵션 사용 가능
<ul>
<li>명시하지 않으면 signed으로 지정</li>
<li>auto increment와 같이 음수가 될 수 없는 값을 저장하는 컬럼에 unsigned가 적절</li>
</ul>
</li>
<li>외래키로 사용하거나 조인의 조건이 되는 컬럼은 옵션을 일치시키는 것이 좋음</li>
</ul>
<h2 id="부동-소수점">부동 소수점</h2>
<ul>
<li>float, double 타입을 사용</li>
<li>소수점의 위치가 고정적이지 않음
<ul>
<li>숫자값의 길이에 따라 유효범위의 소수점 자릿수가 바뀜</li>
</ul>
</li>
<li>근삿값을 저장하는 방식이라 동등 비교는 사용할 수 없음</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="w">	</span><span class="k">create</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">tb_float</span><span class="w"> </span><span class="p">(</span><span class="n">fd1</span><span class="w"> </span><span class="nb">float</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="k">insert</span><span class="w"> </span><span class="k">into</span><span class="w"> </span><span class="n">tb_float</span><span class="w"> </span><span class="k">values</span><span class="w"> </span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">);</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">	</span><span class="c1">-- 결과 x
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">	</span><span class="k">select</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="k">from</span><span class="w"> </span><span class="n">tb_float</span><span class="w"> </span><span class="k">where</span><span class="w"> </span><span class="n">fd1</span><span class="o">=</span><span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>float는 정밀도를 명시하지 않으면 4바이트를 사용해서 유효 자릿수를 8개까지 유지
<ul>
<li>정밀도를 명시하면 최대 8바이트까지 사용가능</li>
</ul>
</li>
<li>부동 소수점 값을 저장할 때 유효 소수점의 자릿수만큼 10을 곱해서 정수로 만드는 방법이 있음</li>
</ul>
<h2 id="decimal">DECIMAL</h2>
<ul>
<li>금액이나 대출이자 등과 같이 고정된 소수점까지 정확하게 관리해야 할 때 사용
<ul>
<li>이런경우 float, double 타입을 사용하면 안됨</li>
</ul>
</li>
<li>MySQL에서 소수점 이하의 값까지 정확하게 관리하려면 DECIMAL 타입을 이용해야 한다.</li>
<li>숫자 하나를 저장하는데 1/2바이트가 필요하므로 한/두자리를 저장하는데 1바이트가 필요하다.</li>
<li>곱셈 연산은 decimal보다 bigint가 더 빠름
<ul>
<li>정수를 관리하기 위해 decimal을 사용하는건 좋지 않음</li>
</ul>
</li>
</ul>
<h2 id="정수-타입의-컬럼을-생성할-때의-주의사항">정수 타입의 컬럼을 생성할 때의 주의사항</h2>
<ul>
<li>부동소수점이나 decimal 타입을 이용할 경우 타입의 이름 뒤에 괄호로 정밀도를 표시하는 것이 일반적
<ul>
<li>ex
<ul>
<li>decimal(20, 5): 정수부를 15자리까지, 소수부를 5자리까지 저장</li>
<li>decimal(20): 정수부로만 20자리까지 저장</li>
</ul>
</li>
</ul>
</li>
<li>decimal은 저장 공간의 크기가 가변적인 데이터 타입이라 저장 가능한 자릿수를 결정함과 동시에 저장 공간의 크기까지 제한한다.</li>
<li>MySQL 5.7까지는 부동/고정 소수점이 아닌 정수 타입을 생성할 때도 크기를 명시할 수 있는 문법을 지원했음</li>
<li>MySQL 8.0부터는 정수 타입에 자릿수를 사용하는 기능은 제거됨
<ul>
<li>테이블을 생성할때 bitint(10) 처럼 자릿수를 명시하면 경고메시지를 표시하고 해당 자릿수는 무시됨</li>
</ul>
</li>
</ul>
<h2 id="자동-증가-auto_increment-옵션-사용">자동 증가 (AUTO_INCREMENT) 옵션 사용</h2>
<ul>
<li>PK를 구성하는 컬럼의 크기가 너무 크거나 PK로 사용할만한 컬럼이 없는 경우 사용</li>
<li><code>auto_increment_increment</code> <code>auto_increment_offset</code> 시스템 설정으로 자동 증가 값을 설정할 수 있음
<ul>
<li>ex. auto_increment_offset=5 auto_increment_increment=10이면 5, 15, 25, 35</li>
</ul>
</li>
<li>테이블당 하나만 사용 가능</li>
<li>다음 증가 값이 얼마인지 <code>show create table</code> 명령으로 조회 가능</li>
<li>auto increment 옵션을 사용한 컬럼은 PK나 유니크 키의 일부로 정의해야 한다.
<ul>
<li>PK나 유니크 키가 여러 개의 컬럼으로 구성되면 컬럼값이 증가하는 패턴이 달라짐
<ul>
<li>MyISAM: 해당 컬럼이 PK나 유니크 키의 아무 위치에서나 사용될 수 있음</li>
<li>InnoDB: auto increment 컬럼으로 시작되는 인덱스를 생성해야 함
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="w">  </span><span class="c1">-- fd_pk2 컬럼이 pk의 뒤쪽에 있어서 에러발생
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">create</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">tb_autoinc_innodb</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">fd_pk1</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">null</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="s1">&#39;0&#39;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">fd_pk2</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">null</span><span class="w"> </span><span class="n">auto_increment</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">primary</span><span class="w"> </span><span class="k">key</span><span class="w"> </span><span class="p">(</span><span class="n">fd_pk1</span><span class="p">,</span><span class="w"> </span><span class="n">fd_pk2</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">)</span><span class="w"> </span><span class="n">engine</span><span class="o">=</span><span class="n">innodb</span><span class="p">;</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="c1">-- fd_pk2 컬럼이 pk의 뒤쪽에 위치하지만 유니크 키의 맨 앞에 위치하므로 정상적으로 테이블이 생성됨
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="w">  </span><span class="k">create</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">tb_autoinc_innodb</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">fd_pk1</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">null</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="s1">&#39;0&#39;</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">fd_pk2</span><span class="w"> </span><span class="nb">int</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">null</span><span class="w"> </span><span class="n">auto_increment</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">primary</span><span class="w"> </span><span class="k">key</span><span class="w"> </span><span class="p">(</span><span class="n">fd_pk1</span><span class="p">,</span><span class="w"> </span><span class="n">fd_pk2</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">unique</span><span class="w"> </span><span class="k">key</span><span class="w"> </span><span class="n">ux_fdpk2</span><span class="w"> </span><span class="p">(</span><span class="n">fd_pk2</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">)</span><span class="w"> </span><span class="n">engine</span><span class="o">=</span><span class="n">innodb</span><span class="p">;</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="날짜와-시간">날짜와 시간</h1>
<table>
<thead>
<tr>
<th>데이터 타입</th>
<th>MySQL 5.6.4 이전</th>
<th>MySQL 5.6.4 부터</th>
</tr>
</thead>
<tbody>
<tr>
<td>YEAR</td>
<td>1바이트</td>
<td>1바이트</td>
</tr>
<tr>
<td>DATE</td>
<td>3바이트</td>
<td>3바이트</td>
</tr>
<tr>
<td>TIME</td>
<td>3바이트</td>
<td>3바이트 + (밀리초 단위 저장 공간)</td>
</tr>
<tr>
<td>DATETIME</td>
<td>8바이트</td>
<td>5바이트 + (밀리초 단위 저장 공간)</td>
</tr>
<tr>
<td>TIMESTAMP</td>
<td>4바이트</td>
<td>4바이트 + (밀리초 단위 저장 공간)</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>밀리초 단위 자릿수</th>
<th>저장공간</th>
</tr>
</thead>
<tbody>
<tr>
<td>없음</td>
<td>0바이트</td>
</tr>
<tr>
<td>1, 2</td>
<td>1바이트</td>
</tr>
<tr>
<td>3, 4</td>
<td>2바이트</td>
</tr>
<tr>
<td>5, 6</td>
<td>3바이트</td>
</tr>
</tbody>
</table>
<ul>
<li>밀리초 단위는 2자리당 1바이트 공간 필요
<ul>
<li>ex. MySQL 8.0에서 DATETIME(6) 타입은 5 + 3바이트를 사용</li>
</ul>
</li>
<li>MySQL의 date, datetime은 컬럼 자체에 타임존 정보가 저장되지 않아서 dbms 커넥션의 타임존과 관계없이 클라이언트로부터 입력된 값을 그대로 저장하고 출력한다.</li>
<li>timestamp는 항상 UTC 타임존으로 저장되므로 타임존이 달라져도 값이 자동으로 보정된다.</li>
</ul>
<h2 id="자동-업데이트">자동 업데이트</h2>
<ul>
<li>MySQL 5.6 이전까지 timestamp 컬럼은 레코드의 다른 컬럼 데이터가 변경될 때마다 시간이 자동으로 업데이트되고, datetime은 그렇지 않은 차이가 있었음</li>
<li>MySQL 5.6 부터는 timestamp, datetime 모두 insert, update 문장이 실행될때마다 자동으로 업데이트되기 위한 옵션을 정의해야 함</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span><span class="lnt">9
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-sql" data-lang="sql"><span class="line"><span class="cl"><span class="w">  </span><span class="k">create</span><span class="w"> </span><span class="k">table</span><span class="w"> </span><span class="n">tb_autoupdate</span><span class="w"> </span><span class="p">(</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">id</span><span class="w"> </span><span class="nb">bigint</span><span class="w"> </span><span class="k">not</span><span class="w"> </span><span class="k">null</span><span class="w"> </span><span class="n">auto_increment</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">title</span><span class="w"> </span><span class="nb">varchar</span><span class="p">(</span><span class="mi">20</span><span class="p">),</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">created_at_ts</span><span class="w"> </span><span class="k">timestamp</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="k">current_timestamp</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">updated_at_ts</span><span class="w"> </span><span class="k">timestamp</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="k">current_timestamp</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="k">update</span><span class="w"> </span><span class="k">current_timestamp</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">created_at_dt</span><span class="w"> </span><span class="n">datetime</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="k">current_timestamp</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="n">updated_at_dt</span><span class="w"> </span><span class="n">datetime</span><span class="w"> </span><span class="k">default</span><span class="w"> </span><span class="k">current_timestamp</span><span class="w"> </span><span class="k">on</span><span class="w"> </span><span class="k">update</span><span class="w"> </span><span class="k">current_timestamp</span><span class="p">,</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">    </span><span class="k">primary</span><span class="w"> </span><span class="k">key</span><span class="w"> </span><span class="p">(</span><span class="n">id</span><span class="p">)</span><span class="w">
</span></span></span><span class="line"><span class="cl"><span class="w">  </span><span class="p">);</span><span class="w">
</span></span></span></code></pre></td></tr></table>
</div>
</div>]]></description>
            <pubDate>Fri, 29 Mar 2024 08:00:00 &#43;0000</pubDate>
            <guid isPermaLink="true">http://localhost:1313/posts/database/db_15_1/</guid>
        </item>
    
    </channel>
</rss>
